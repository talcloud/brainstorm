function TessMat = in_tess_mrimask(MriFile)
% IN_TESS_MRIMASK: Import an MRI as a mask or atlas, and tesselate the volumes in it

% @=============================================================================
% This function is part of the Brainstorm software:
% http://neuroimage.usc.edu/brainstorm
% 
% Copyright (c)2000-2016 University of Southern California & McGill University
% This software is distributed under the terms of the GNU General Public License
% as published by the Free Software Foundation. Further details on the GPL
% license can be found at http://www.gnu.org/copyleft/gpl.html.
% 
% FOR RESEARCH PURPOSES ONLY. THE SOFTWARE IS PROVIDED "AS IS," AND THE
% UNIVERSITY OF SOUTHERN CALIFORNIA AND ITS COLLABORATORS DO NOT MAKE ANY
% WARRANTY, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
% MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, NOR DO THEY ASSUME ANY
% LIABILITY OR RESPONSIBILITY FOR THE USE OF THIS SOFTWARE.
%
% For more information type "brainstorm license" at command prompt.
% =============================================================================@
%
% Authors: Francois Tadel, 2012-2013

% Read MRI volume
sMri = in_mri(MriFile);
sMri.Cube = double(sMri.Cube);
% Get al the values in the MRI
allValues = unique(sMri.Cube);
% If values are not integers, it is not a mask or an atlas: it has to be binarized first
if any(allValues ~= round(allValues))
    % Warning: not a binary mask
    isConfirm = java_dialog('confirm', ['Warning: This is not a binary mask.' 10 'Try to import this MRI as a surface anyway?'], 'Import binary mask');
    if ~isConfirm
        TessMat = [];
        return;
    end
    % Analyze MRI histogram
    Histogram = mri_histogram(sMri.Cube);
    % Binarize based on background level
    sMri.Cube = (sMri.Cube > Histogram.bgLevel);
    allValues = [0,1];
end


% Default labels for FreeSurfer ASEG.MGZ
if (length(allValues) > 10) && (~isempty(strfind(MriFile, 'aseg.mgz')) || ~isempty(strfind(MriFile, 'aseg.auto.mgz')) || ~isempty(strfind(MriFile, 'aseg.auto_noCCseg.mgz')))
    Labels = {...
        ... 0,  'Unknown'; ...
        ... 1,  'Left_Cerebral_Exterior'; ...
        ... 2,  'Left-Cerebral-White-Matter'; ...
        ... 3,  'Left-Cerebral-Cortex'; ...
        ... 4,  'Left-Lateral-Ventricle'; ...
        ... 5,  'Left-Inf-Lat-Vent'; ...
        ... 7,  'Left-Cerebellum-White-Matter'; ...
       ... 14,  '3rd-Ventricle'; ...
       ... 15,  '4th-Ventricle'; ...
       ... 24,  'CSF'; ...
       ... 28,  'VentralDC L'; ...
       ... 30,  'Left-vessel'; ...
       ... 31,  'Choroid-plexus L'; ...
       ... 40,  'Right_Cerebral_Exterior'; ...
       ... 41,  'Right-Cerebral-White-Matter'; ...
       ... 42,  'Right-Cerebral-Cortex'; ...
       ... 43,  'Right-Lateral-Ventricle'; ...
       ... 44,  'Right-Inf-Lat-Vent'; ...
       ... 46,  'Right-Cerebellum-White-Matter'; ...
       ... 60,  'VentralDC R'; ...
       ... 62,  'Right-vessel'; ...
       ... 63,  'Choroid-plexus R'; ...
       ... 72,  '5th-Ventricle'; ...
       ... 77,  'WM-hypointensities'; ...
       ... 78,  'Left-WM-hypointensities'; ...
       ...  79,  'Right-WM-hypointensities'; ...
       ...  80,  'non-WM-hypointensities'; ...
       ...  81,  'Left-non-WM-hypointensities'; ...
       ...  82,  'Right-non-WM-hypointensities'; ...
      ... 85,  'Optic-Chiasm'; ...
      ... 251,  'CC_Posterior'; ...
      ... 252,  'CC_Mid_Posterior'; ...
      ... 253,  'CC_Central'; ...
      ... 254,  'CC_Mid_Anterior'; ...
      ... 255,  'CC_Anterior'; ...
       16,  'Brainstem'; ...
        8,  'Cerebellum L'; ...
       47,  'Cerebellum R'; ...
       26,  'Accumbens L'; ...
       58,  'Accumbens R'; ...
       18,  'Amygdala L'; ...
       54,  'Amygdala R'; ...
       11,  'Caudate L'; ...
       50,  'Caudate R'; ...
       17,  'Hippocampus L'; ...
       53,  'Hippocampus R'; ...
       13,  'Pallidum L'; ...
       52,  'Pallidum R'; ...
       12,  'Putamen L'; ...
       51,  'Putamen R'; ...
        9,  'Thalamus L'; ...
       10,  'Thalamus L'; ...
       48,  'Thalamus R'; ...
       49,  'Thalamus R'; ...
      };
    % Grouping the cerebellum white+cortex voxels
    sMri.Cube(sMri.Cube == 7) = 8;
    sMri.Cube(sMri.Cube == 46) = 47;

    % Keep only the labelled areas
    [allValues, I, J] = intersect([Labels{:,1}], allValues);
    Labels = Labels(I,:);
    % Get labelled values in alphabetical order 
    allValues = [Labels{:,1}];
else
    % Skip the first value (background)
    allValues(1) = [];
    Labels = {};
end

iEmpty = [];
TessMat = repmat(struct('Comment', [], 'Vertices', [], 'Faces', []), [1, length(allValues)]);
% Generate a tesselation for all the others
for i = 1:length(allValues)
    % Display progress bar
    if (length(allValues) > 1)
        bst_progress('text', sprintf('Importing atlas surface #%d/%d...', i, length(allValues)));
    end
    % Comment field
    if ~isempty(Labels)
        TessMat(i).Comment = Labels{i,2};
    elseif (length(allValues) > 1)
        TessMat(i).Comment = sprintf('%d', allValues(i));
    end
    % Get the binary mask of the current region
    mask = (sMri.Cube == allValues(i));
    % Fill small holes
    mask = mri_dilate(mask, 1);
    mask = mask & ~mri_dilate(~mask, 1);
    
    % Create an isosurface
    [TessMat(i).Faces, TessMat(i).Vertices] = isosurface(mask, 0.5);
    % Skip empty surfaces
    if isempty(TessMat(i).Vertices);
        iEmpty(end+1) = i;
        continue;
    end
    % Add half a voxel: ONLY TO MATCH FREESURFER TESSELATED MASKS (????)
    % TessMat(i).Vertices = bst_bsxfun(@plus, TessMat(i).Vertices, [0.5 -0.5 0.5]);
    % Convert to Brainstorm format
    TessMat(i).Vertices = TessMat(i).Vertices(:, [2 1 3]);
    TessMat(i).Faces    = TessMat(i).Faces(:, [2 1 3]);
    % Convert to millimeters
    TessMat(i).Vertices = TessMat(i).Vertices ./ 1000;
    TessMat(i).Vertices = bst_bsxfun(@times, TessMat(i).Vertices, sMri.Voxsize);
    % Remove small objects
    [TessMat(i).Vertices, TessMat(i).Faces] = tess_remove_small(TessMat(i).Vertices, TessMat(i).Faces);
    
    % Compute vertex-vertex connectivity
    VertConn = tess_vertconn(TessMat(i).Vertices, TessMat(i).Faces);
    % Smooth surface
    TessMat(i).Vertices = tess_smooth(TessMat(i).Vertices, 1, 2, VertConn, 0);
    % Enlarge a bit
    VertNormals = tess_normals(TessMat(i).Vertices, TessMat(i).Faces, VertConn);
    TessMat(i).Vertices = TessMat(i).Vertices + 0.0002 * VertNormals;
end

% Remove empty surfaces
if ~isempty(iEmpty)
    TessMat(iEmpty) = [];
end

